---
title: "Elasticsearchのnested型を理解する：なぜ必要で、いつ使うべきか"
emoji: "🔍"
type: "tech"
topics: ["Elasticsearch", "Lucene", "データモデリング", "検索エンジン", "パフォーマンス"]
published: false
---

## オブジェクト配列の検索で困ったことはありませんか

Elasticsearchでユーザー情報を検索していたら、こんな経験をしたことはないでしょうか。

「Alice White」というユーザーを検索したはずなのに、なぜか「John Smith」と「Alice White」の両方が入った文書がヒットしてしまう。データは正しく入っているはずなのに、検索結果がおかしい...

実はこれ、Elasticsearchの仕様によるものです。

## Elasticsearchがオブジェクト配列を平坦化する理由

以下のような文書をインデックスしてみましょう

```json
{
  "group": "fans",
  "user": [
    {
      "first": "john",
      "last": "smith"
    },
    {
      "first": "alice",
      "last": "white"
    }
  ]
}
```

驚くかもしれませんが、Elasticsearchは内部的にこのデータを次のように変換してしまいます

```json
{
  "group": "fans",
  "user.first": ["john", "alice"],
  "user.last": ["smith", "white"]
}
```

配列内のオブジェクトがバラバラになってしまいました。これで「first: alice AND last: smith」で検索すると、本来存在しない組み合わせでも文書がヒットしてしまうわけです。

なぜこんなことが起きるのか？それはElasticsearchの基盤であるLuceneが、根本的に平坦な構造しか扱えないからです。

## nested型の登場

この問題を解決するのがnested型です。

nested型を使うと、配列内の各オブジェクトを独立した「隠れた文書」として保存します。100個のオブジェクトを含む配列があれば、内部的には101個の文書（親文書1個 + 子文書100個）として管理されるイメージです。

ただし、これらの文書は同じLuceneセグメント内に物理的に隣接して配置されます。この工夫により、検索時のパフォーマンスを保ちながら、オブジェクトの境界を維持できるのです。

## nested型の使い方

### 基本的なクエリ

通常のクエリとは少し違い、専用の`nested`クエリを使います

```json
GET /my-index/_search
{
  "query": {
    "nested": {
      "path": "user",
      "query": {
        "bool": {
          "must": [
            { "match": { "user.first": "alice" }},
            { "match": { "user.last": "white" }}
          ]
        }
      }
    }
  }
}
```

`path`パラメータでnestedフィールドを指定するのがポイントです。

### どのオブジェクトがマッチしたか知りたいとき

nested型の困った点は、デフォルトではどのオブジェクトがマッチしたのか分からないことです。`inner_hits`を使えば解決できます

```json
GET /my-index/_search
{
  "query": {
    "nested": {
      "path": "user",
      "query": {
        "match": { "user.first": "alice" }
      },
      "inner_hits": {}
    }
  }
}
```

## nested型を使うケース

### 向いているケース

1. **商品のバリエーション管理**
   - 例：Tシャツの色とサイズの組み合わせ
   - `{color: "blue", size: "M"}` のような正確な組み合わせ検索が必要

2. **ブログのコメント**
   - 投稿者と内容をセットで検索したい
   - ただし更新頻度が低い場合

3. **イベントの参加者リスト**
   - 参加者の属性を組み合わせて検索

### 向いていないケース

1. **頻繁に更新されるデータ**
   - nestedオブジェクトを1つ更新するだけで、文書全体を再インデックスする必要があります
   - 例：リアルタイムのコメント欄

2. **大量のオブジェクトを含む配列**
   - デフォルトでは1文書あたり10,000個が上限
   - それぞれが独立した文書として保存されるため、インデックスサイズが膨張します

3. **Kibanaでの分析が必要な場合**
   - Discoverでは検索できますが、LensやVisualizationでは使えません

## パフォーマンスへの影響

nested型は便利ですが、タダではありません

- **インデックスサイズ**: オブジェクト数に比例して増加
- **更新コスト**: 1つの変更で文書全体の再インデックスが発生
- **クエリ速度**: 通常のフィールドより遅い（ただしjoin型よりは5-10倍速い）

個人のプロジェクトでは、1000件程度のnestedオブジェクトを含む文書で、インデックスサイズが2倍近くになったケースもありました。

## 他の選択肢との比較

| アプローチ | メリット | デメリット | 使用場面 |
|----------|---------|-----------|---------|
| object型（デフォルト） | 高速、シンプル | 関係性が失われる | 組み合わせ検索が不要な場合 |
| nested型 | 関係性を維持、そこそこ高速 | 更新コスト大、サイズ増加 | 読み取り中心で正確性が必要 |
| join型（parent-child） | 個別更新可能 | 非常に遅い（5-10倍） | 子の更新が頻繁 |
| 非正規化 | 最速 | データ重複、管理が複雑 | パフォーマンス最優先 |

## 実装のベストプラクティス

### nested検索時にフィルタリングを行う

nested検索は重いので、まず通常のフィルタで文書を絞り込んでから実行しましょう

```json
{
  "query": {
    "bool": {
      "filter": [
        { "term": { "group": "fans" } }  // まずこれで絞る
      ],
      "must": [
        {
          "nested": {
            "path": "user",
            "query": { ... }
          }
        }
      ]
    }
  }
}
```

### include_in_parentの活用
`include_in_parent`は検索の柔軟性とパフォーマンスの両立を図るオプションです。

このオプションを有効にすると、 nestedオブジェクトとして個別にインデックスされると同時に、通常のオブジェクト配列としても親ドキュメントにインデックスされます。

これにより、nestedクエリを使わずに通常のフィールドとして検索することも可能になります。

```json
{
  "mappings": {
    "properties": {
      "user": {
        "type": "nested",
        "include_in_parent": true
      }
    }
  }
}
```

## まとめ

nested型は、Elasticsearchでオブジェクト配列の関係性を保持する強力なツールです。ただし、銀の弾丸ではありません。

更新頻度、データ量、パフォーマンス要件を総合的に判断して、本当にnested型が必要かを検討しましょう。多くの場合、データモデルを見直して非正規化する方が、シンプルで高速な解決策になることもあります。

実際のプロジェクトでnested型を採用する前に、小規模なデータでパフォーマンステストを実施することをお勧めします。思わぬボトルネックに後から気づくより、最初から適切な選択をする方が、長期的には楽になるはずです。