---
title: "Elasticsearchのnested型詳細解析：アーキテクチャ、パフォーマンス、実装戦略"
emoji: "🔍"
type: "tech"
topics: ["Elasticsearch", "Lucene", "データモデリング", "検索エンジン", "パフォーマンス"]
published: false
---

## はじめに

Elasticsearchは分散型検索・分析エンジンとして、基本的に内部オブジェクト（inner objects）という概念を持ちません。このアーキテクチャ的特徴は、JSON文書内のオブジェクト配列をインデックスする際に重要な結果をもたらします。オブジェクト配列を含む文書をインデックスすると、Elasticsearchはこの階層構造をフィールド名と値の単純なリストに平坦化（flattening）します。

この平坦化プロセスの意味を理解するため、次のユーザー情報を含む文書の例を見てみましょう。この文書には`user`フィールドに2つのオブジェクトからなる配列が含まれています。

```json
{
  "group": "fans",
  "user": [
    {
      "first": "john",
      "last": "smith"
    },
    {
      "first": "alice",
      "last": "white"
    }
  ]
}
```

この文書を基本的な`object`型でインデックスすると、Elasticsearchは内部的にデータを次のように再構成して保存します：

```json
{
  "group": "fans",
  "user.first": [ "john", "alice" ],
  "user.last": [ "smith", "white" ]
}
```

この内部表現方式の重大な問題は、各オブジェクト内のフィールド間の関連性が失われることです。"John"と"Smith"、"Alice"と"White"の間の元の関係が破壊されます。これにより、`user.first`フィールド値が"Alice"で`user.last`フィールド値が"Smith"であるユーザーを検索するクエリを実行すると、予想に反してこの文書が検索結果に含まれるという論理的エラーが発生します。

`user.first`配列に"alice"が存在し、`user.last`配列に"smith"が存在するためです。

核心的な問題は単にオブジェクトを保存することではなく、配列内の各オブジェクト内部の関係的整合性（relational integrity）をクエリ時点まで維持することです。基本的な`object`型はこの整合性を破壊します。Elasticsearchは平坦な構造に最適化された文書ストレージですが、基本データ形式であるJSONは入れ子構造をサポートしています。このデータを検索可能にするため、内部検索エンジンであるLuceneはこれを平坦化する必要があります。このプロセスでオブジェクト配列内のキーと値のペアのグループ化が失われるため、配列の各オブジェクトを独立したクエリ単位として扱うようElasticsearchに指示する特別なメカニズムが必要です。この役割を果たすのが`nested`データ型です。

## 1. nestedデータ型詳細分析

### 1.1 核心概念：独立したクエリのための特殊オブジェクト型

nested型は「オブジェクトデータ型の特化バージョン」として定義されます。この型の唯一の目的は、オブジェクト配列が互いに独立してインデックスされ、クエリできるようにすることです。つまり、はじめにで説明した平坦化問題に対する直接的な解決策です。

### 1.2 内部動作原理：「隠された文書」モデル

nested型のパフォーマンス特性を理解するには、内部動作方式を知ることが非常に重要です。nested型として指定されたフィールドのオブジェクトは、内部的にそれぞれ別個の隠されたLucene文書としてインデックスされます。

重要な点は、元の文書（ルート文書）とそれに属するすべてのnestedオブジェクト（隠された文書）が同じLuceneブロックおよびセグメントに一緒に保存されることです。このデータ局所性（co-location）は、他の結合方式と比較してnestedクエリが相対的に高速なパフォーマンスを示す核心的な理由です。例えば、100個のnestedオブジェクトを持つ1つのElasticsearch文書は、内部的に101個の個別Lucene文書に変換されます。この事実は、nested型がより多くのインデックスサイズとリソースを消費する理由を明確に説明します。

この構造は、nested型が単純な機能ではなく、Luceneレベルで結合を実行するための抽象化レイヤーであることを示唆します。Luceneは根本的に平坦な文書を扱うため、関係をモデリングするには結合が必要です。nested型はインデックス時点でデータを事前に結合する特定の方式を実装したものです。つまり、分離されているが物理的に隣接した文書を生成します。したがってnestedクエリは、このデータ局所性を活用して速度を向上させる特殊な結合クエリです。この抽象化により開発者は手動結合の複雑さから解放されますが、文書全体を再インデックスする必要があるなど、基盤モデルの厳格な制約を受け入れる必要があります。

### 1.3 主要機能および活用法（コード例を含む）

nested型は単純なクエリを超えて様々な相互作用をサポートします。

#### nestedクエリ

nestedフィールドをクエリする基本的なツールです。はじめにで失敗したboolクエリとは異なり、nestedクエリは各オブジェクトの境界を尊重して正確な結果を返します。クエリ時には必ず`path`パラメータを使用して対象nestedフィールドを指定する必要があります。

```json
GET my-index-000001/_search
{
  "query": {
    "nested": {
      "path": "user",
      "query": {
        "bool": {
          "must": [
            { "match": { "user.first": "Alice" }},
            { "match": { "user.last": "White" }}
          ]
        }
      }
    }
  }
}
```

このクエリは`user`配列内で`first`が"Alice"で`last`が"White"であるオブジェクトを正確に検索します。

#### nestedおよびreverse_nested集計

nestedフィールドに対する集計（aggregation）を実行するにはnested集計を使用する必要があります。これによりnestedオブジェクト内の値を基準に統計を取ることができます。逆に`reverse_nested`集計を使用すると、nestedコンテキストから抜け出して上位文書（ルート文書）のフィールドを基準に集計できます。

```json
GET my-index-000001/_search
{
  "size": 0,
  "aggs": {
    "users": {
      "nested": {
        "path": "user"
      },
      "aggs": {
        "last_names": {
          "terms": { "field": "user.last.keyword" }
        }
      }
    }
  }
}
```

#### nestedソート

検索結果をnestedオブジェクト内のフィールド値でソートするには、特別なnestedソート構文を使用する必要があります。

```json
GET my-index-000001/_search
{
  "query": {...},
  "sort": [
    {
      "user.last.keyword": {
        "order": "asc",
        "nested": {
          "path": "user"
        }
      }
    }
  ]
}
```

#### nested Inner Hits

nestedクエリの重要な使用性特徴の1つが`inner_hits`です。基本的にnestedクエリは条件に一致するnestedオブジェクトを含む上位文書全体を返すだけで、どのnestedオブジェクトがクエリと一致したかは示しません。`inner_hits`はこの問題を解決し、検索結果内で具体的にどのnestedオブジェクトがマッチしたかを確認し、ハイライトできるようにします。

```json
GET my-index-000001/_search
{
  "query": {
    "nested": {
      "path": "user",
      "query": {
        "match": { "user.first": "Alice" }
      },
      "inner_hits": {}
    }
  }
}
```

## 2. nested型の妥当性：利点および活用事例

### 2.1 妥協のないクエリ正確性

nested型の最も根本的な利点は、オブジェクト配列に対するクエリが論理的に正確であることを保証することです。はじめにの例で"Alice Smith"を検索するクエリがnested型を使用したときに正しく結果を返さないように、nestedはクエリ時点のデータ整合性を保持します。

### 2.2 join型と比較した優れたクエリパフォーマンス

nestedクエリは平坦なデータをクエリするより遅いですが、join型（parent-child）クエリと比較すると圧倒的に高速です。複数の資料によると、joinクエリはnestedクエリより5倍から10倍、場合によっては数百倍まで遅くなる可能性があると報告されています。

このパフォーマンス差はクエリ時点の結合ロジックに起因します。nested結合は上位文書と下位文書が同じLuceneブロックに物理的に一緒に位置するため非常に高速です。一方、joinクエリはより高価なグローバルオーディナル（global ordinals）検索とメモリ集約的な結合マップを必要とし、パフォーマンス低下を引き起こします。

### 2.3 原子的データ管理

文書全体（上位文書 + すべてのnestedオブジェクト）は1つの原子単位（atomic unit）として扱われます。文書を更新すると、すべての部分が同時に更新されて検索に反映されます。これは文書内で強力な一貫性を提供します。

### 2.4 実用的シナリオ：nestedが正しい選択である場合

nested型はすべての状況に適した万能解決策ではなく、特定のシナリオでその価値を発揮します。

- **読み取り中心、まれな書き込み（Read-Heavy, Write-Infrequently）**：nestedオブジェクトの内容がめったに変更されず、一度インデックスされた後主に読み取り操作に使用されるデータに最も理想的です。
- **一対少（One-to-Few）関係**：上位文書が管理可能な数のnestedオブジェクトを持つ場合に適しています。例えば、商品の属性、投稿のタグ、個人の住所リストなどが該当します。
- **具体的な活用例**：
  - 電子商取引：`product`文書に`{color: "blue", size: "M"}, {color: "red", size: "L"}`のような`attributes`をnested配列として含む場合
  - コンテンツ管理：`blog_post`文書に`comments`をnested配列として含む場合
  - イベント管理：`event`文書に参加者リスト（`attendees`）をnested配列として含む場合

## 3. 隠されたコスト：制限とパフォーマンストレードオフ

nested型は強力な機能を提供しますが、それに相応するコストと制限を明確に認識する必要があります。

### 3.1 アキレス腱：インデックスおよび更新の非効率性

nested型の最大の欠点は更新コストです。Elasticsearchの文書は不変（immutable）です。したがって、nestedオブジェクト配列の中の1つのオブジェクトで1つの値だけを追加、修正、削除しても、Elasticsearchは変更されていない他のすべてのnestedオブジェクトを含む上位文書全体を再インデックスする必要があります。

このプロセスは内部的に次のように進行します：nestedオブジェクト更新要求が来ると、既存の上位文書とそれに属するすべての隠されたLucene文書を削除済み（deleted）としてマークし、変更事項が適用された新しい上位文書とそれに属するすべての隠された文書を新たに生成してインデックスします。

このメカニズムにより、nested型は書き込み操作が頻繁であったり、nestedデータが頻繁に変更されるワークロード（例：活発なコメントセクション）には極めて非効率的で不適切です。このコストは文書のサイズとnestedオブジェクトの数に比例して増加します。

### 3.2 クエリパフォーマンスのオーバーヘッドと複雑性

- **クエリ時点の結合**：nestedクエリは本質的にクエリ時点で結合演算を実行するため、平坦なフィールドに対する単純なクエリよりコストが高くなります。このプロセスはより多くのCPUとメモリを消費します。
- **複雑な構文**：クエリ構文が標準クエリより複雑で冗長です。開発者は`nested`クエリという特定の構造を使用する必要があるため、コードの可読性が低下する可能性があります。

### 3.3 リソース消費：インデックスサイズ、メモリ、および制限

- **インデックス膨張（Index Bloat）**：各nestedオブジェクトが別個のLucene文書になるため、Luceneレベルの総文書数が大幅に増加し、全体のインデックスサイズが膨張する可能性があります。
- **ヒープメモリ使用量**：nested文書はより高いヒープメモリ使用量を引き起こす可能性があります。
- **物理的制限**：Elasticsearchは過度な使用とマッピング爆発（mapping explosion）を防ぐため、設定可能な制限を設けています。
  - `index.mapping.nested_fields.limit`：インデックスごとに許可される固有のnested型マッピングの最大数（デフォルト50）
  - `index.mapping.nested_objects.limit`：単一文書がすべてのnested型を通じて含むことができるnested JSONオブジェクトの最大数（デフォルト10,000）

### 3.4 ツールおよび機能的制約

- **Kibana**：nestedフィールドはKibanaで完全にサポートされていません。Discoverタブで検索は可能ですが、Lensのような視覚化ツールの作成には使用できません。これは分析のためにKibanaに大きく依存するユーザーにとって重大な実用的制約です。
- **オブジェクト間のクロス参照不可**：単一クエリ内で異なるnested文書間で「クロス参照」することはできません。例えば、`comments.author`フィールドでフィルタリングしながら同時に`tags.name`フィールドで集計することは、同じnestedスコープ内では不可能です。

これらの特性は、nested型の選択が単純なスキーマ決定ではなく、データモデリング、アプリケーションロジック、インフラストラクチャ容量の間に密接な結合を作り出すことを示しています。エンジニアがクエリ正確性問題を解決するためにnestedを選択すると、アプリケーション開発者は複雑なnestedクエリと`inner_hits`ロジックを作成する必要があります。

nestedデータを更新する必要がある場合、アプリケーションは変更された部分だけでなく文書全体を送信する必要があるため、ネットワークトラフィックとインデックス負荷が増加します。増加したインデックスおよびクエリ負荷はElasticsearchクラスタのCPU、メモリ、ディスクI/Oにより大きな圧力をかけ、最終的により強力なハードウェアやより大きなクラスタを必要とし、インフラストラクチャコストに影響を与える可能性があります。このように、単純に見えるマッピング選択1つが技術スタック全体にわたって広範な波及効果をもたらします。

## 4. 代替案の比較分析

nested型が唯一の解決策ではありません。データモデリング戦略を策定する際、他のオプションとの長所と短所を比較することが不可欠です。

### 4.1 基本object型（平坦化）

- **使用時期**：オブジェクト配列があるが、単一オブジェクト内のフィールドの組み合わせでクエリする必要が全くない場合に使用します。オブジェクト間の相関関係が問題にならない単純なデータ構造に適しています。
- **利点**：インデックスおよびクエリパフォーマンスが最も高く、モデルが最も単純です。
- **欠点**：フィールド間の関係が失われ、複雑なクエリで不正確な結果を引き起こします。

### 4.2 flattened型

- **使用時期**：キーの数が非常に多いか予測不可能なオブジェクトを扱う際に「マッピング爆発」を防ぐために使用します（例：ユーザーが任意に定義するメタデータ、多数のフィールドを持つログデータ）。
- **利点**：マッピングフィールド数制限を回避でき、インデックスオーバーヘッドが低いです。
- **欠点**：クエリ機能に深刻な制約があります。すべての値は`keyword`として扱われ、数値範囲クエリ、ハイライト、様々な集計機能、全文検索分析が不可能です。nestedオブジェクトに対する豊富なクエリが必要な場合、真の代替案にはなりません。

### 4.3 join型（Parent-Child関係）

- **使用時期**：「子」文書が「親」文書と独立して、かつ頻繁に更新される一対多（one-to-many）関係で使用します。これはnested型の更新非効率性に対する直接的な代替案です。
- **利点**：更新効率が高いです（子文書は親の再インデックスなしに追加/修正/削除可能）。概念的に関係モデルにより近いです。
- **欠点**：クエリパフォーマンスが著しく低く（nestedより5-10倍遅い）、結合マップのためのメモリオーバーヘッドが大きく、運用の複雑性（親と子は同じシャードにルーティングされる必要がある）が存在します。

### 4.4 非正規化およびアプリケーション側結合

- **使用時期**：最も推奨される「Elasticsearchネイティブ」アプローチです。データを平坦に再構成することを意味し、このプロセスで情報が重複する可能性があります。例えば、`sales` nested配列を持つ`product`文書の代わりに、各販売文書が関連製品情報を含む別の`sales`インデックスを生成する方式です。
- **利点**：検索時点のすべての結合を回避してクエリパフォーマンスを最大化します。Elasticsearch内では最も単純なデータモデルです。
- **欠点**：複雑性がアプリケーション層に移転し（アプリケーション側結合）、データ重複により保存空間コストが増加し、更新が複雑になります（複数の場所のデータを更新する必要がある）。

### 4.5 核心意思決定表

次の表は複雑なトレードオフを明確で理解しやすい形式で要約し、ユーザーがデータモデルを選択する際の重要なツールとなります。

| 特徴 / 特性 | object（基本） | nested | flattened | join（Parent-Child） | 非正規化（Denormalization） |
|------------|---------------|--------|-----------|-------------------|-------------------------|
| 核心使用事例 | 単純なオブジェクト、配列に対する関係クエリ不要 | 独立した正確なクエリが必要なオブジェクト配列。読み取り中心。 | マッピング爆発防止のための多数/未知のキーを持つオブジェクト。 | 子の更新が頻繁な一対多関係。書き込み中心（子）。 | クエリ速度が最優先のパフォーマンス重視アプリケーション。 |
| 関係整合性 | 失われる（平坦化） | 文書内で保持 | keywordとして保持されるが、型別クエリ不可 | 別個の文書間で維持 | アプリケーションロジックで維持。 |
| クエリパフォーマンス | 最高（単純クエリ） | 高い（結合により平坦構造より遅い） | 高い（keywordスタイルクエリに限る） | 低い（nestedより5-10倍遅い） | 最高（ES内結合なし）。 |
| インデックス/更新パフォーマンス | 最高 | 低い（どんな変更でも文書全体を再インデックス） | 高い | 高い（子更新時）；親更新は別個 | 中程度（複数文書の更新が必要な可能性）。 |
| クエリ複雑性 | 低い | 高い（nestedクエリ、inner_hits必要） | 低い（クエリタイプ制限的） | 高い（has_child/has_parentクエリ必要） | 低い（ES内）；高い（アプリケーション内）。 |
| リソースコスト（メモリ/保存空間） | 低い | 高い（インデックス膨張、ヒープ使用量） | 低い（単一フィールドマッピング） | 高い（メモリ内結合マップ、シャード管理オーバーヘッド） | 高い（データ重複による保存空間）。 |

## 5. ベストプラクティスおよび戦略的推奨事項

### 5.1 意思決定フレームワーク：正しい経路の選択

データモデルを選択する際は、次の質問を順番に検討することが有用です。

1. オブジェクト配列があるか？ない場合は平坦なモデルを使用します。
2. 配列内のオブジェクト内部のフィールド間関係に依存するクエリが必要か？そうでなければ基本object型を使用します。
3. nestedオブジェクトはどの程度頻繁に更新されるか？頻繁な場合、nestedは危険です。join（子が独立して更新される場合）または非正規化を検討すべきです。
4. 更新がまれ（読み取り中心）な場合、クエリパフォーマンスが絶対的に最も重要か？そうであれば非正規化を最初に検討します。nestedのパフォーマンスが「十分良く」、アプリケーション側ロジックより管理が簡単であればnestedを使用します。
5. 予測不可能で多数のフィールドを持つオブジェクトがあるか？flattenedを使用しますが、クエリ制約を明確に認識する必要があります。

### 5.2 nested型の効果的な実装

- **マッピング**：nestedマッピングは常に明示的に定義する必要があります。複雑なオブジェクトに対して動的マッピングに依存しないでください。
- **更新**：nestedオブジェクトを追加、修正、削除する際は、クライアントで文書全体を取得して再送信する代わりに、Update APIとpainlessスクリプトを使用することが標準的な方法です。これによりネットワークオーバーヘッドを削減し、更新ロジックをサーバー側で処理できます。

### 5.3 nestedクエリおよび集計の最適化

nested型のパフォーマンスを最大化するための実用的なチューニングのヒントは次のとおりです。

- **事前フィルタリング**：nestedクエリを実行する前に、`filter`コンテキストや上位レベルの`bool`クエリを使用して文書セットを削減することが最も効果的な最適化方法です。これにより、高価なnested結合演算を最小限の文書に対してのみ実行することが保証されます。
- **バケット数制限**：nested集計内で`terms`集計を使用する際は、`size`パラメータを使用して返されるバケット数を制限してください。これは過度なメモリ使用を防ぐのに役立ちます。
- **composite集計の使用**：nestedフィールドで高カーディナリティ集計を実行する必要がある場合、`composite`集計を使用して結果を効率的にページネーションしてください。これによりメモリ負担を大幅に削減できます。
- **不要なスコアリング回避**：フィルタリングのみが目的の場合、nestedクエリを`bool`クエリの`filter`節内に配置してスコア計算オーバーヘッドを回避してください。

### 5.4 高度なチューニング：include_in_parentとinclude_in_rootハイブリッド戦略

- **機能**：`include_in_parent`または`include_in_root`を`true`に設定すると、Elasticsearchはnestedオブジェクトのデータを2回インデックスします。1回は別個のnested文書として、もう1回は上位（parent）または最上位（root）文書に平坦化されたフィールドとしてインデックスします。
- **使用事例**：このハイブリッドアプローチにより、平坦化されたフィールドに対しては高速で単純なクエリ（例：Kibanaでのフィルタリングや単純な集計）を使用し、完全な関係正確性が必要な場合はより遅いが精密なnestedクエリを使用できます。
- **トレードオフ**：コストはデータを2回保存するため増加するインデックスサイズとインデックス時間です。これは典型的な空間-時間トレードオフ（space-time tradeoff）です。
- **廃止議論**：これらのオプションはより明示的な`copy_to`パラメータを優先して廃止が検討されましたが、すべてのフィールドを個別に指定せずに全体のオブジェクトを便利にコピーできるという利点のため、依然として残っています。

### 5.5 避けるべき一般的な落とし穴

- **nestedの乱用**：必要のない単純なデータ構造に適用して不要な複雑性とパフォーマンスオーバーヘッドを引き起こす場合。
- **nestedクエリの忘却**：nestedフィールドを標準クエリで照会して不正確な結果やエラーを引き起こす場合。
- **更新コストの無視**：頻繁に更新されるデータにnestedを使用して深刻なインデックスパフォーマンス低下を引き起こす場合。
- **廃止の誤解**：nestedフィールド型は廃止されておらず、廃止されたのはElasticsearch 7.x以前のドキュメント型概念であることを明確にする必要があります。

## 結論

この分析を総合すると、Elasticsearchで関係データをモデリングする際に「最良の」普遍的な解決策はないという結論に達します。最適な選択は、クエリ要件、更新頻度、パフォーマンス期待値、運用複雑性の間のバランスを取る戦略的決定です。

nested型は強力ですが特化したツールです。これはデフォルトの選択ではなく、複数のツールの1つとして考慮されるべきです。多くの場合、「非正規化優先」の考え方が最もパフォーマンスが優れ、拡張可能な経路であり、nestedやjoinのようなツールは非正規化が非現実的または不可能な特定のケースのために残しておくべきです。最終的にこの報告書は、読者が自身の特定の使用事例に適した情報に基づいた、状況認識的な決定を下せるよう能力を付与することを目的としています。